/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

*/
// client.h -- primary header for client

//define	PARANOID			// speed sapping error checking

#include <math.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#include "ref_public.h"
#include "vid_public.h"

#include "screen.h"
#include "sound.h"
#include "input.h"
#include "keys.h"

// for curl downloading
#include <curl/curl.h>

//=============================================================================

typedef struct
{
	qboolean		valid;			// cleared if delta parsing was invalid
	int				serverframe;
	int				servertime;		// server time the message is valid for (in msec)
	int				deltaframe;
	byte			areabits[MAX_MAP_AREAS >> 3];		// portalarea visibility bits
	player_state_t	playerstate;
	int				num_entities;
	int				parse_entities;	// non-masked index into cl_parse_entities array
} frame_t;

typedef struct
{
	entity_state_t	baseline;		// delta from this if not from a previous frame
	entity_state_t	current;
	entity_state_t	prev;			// will always be valid, but might just be a copy of current

	int			serverframe;		// if not current, this ent isn't in the frame

	int			trailcount;			// for diminishing grenade trails
	vec3_t		lerp_origin;		// for trails (variable hz)

	int			fly_stoptime;
} centity_t;

#define MAX_CLIENTWEAPONMODELS		20		// PGM - upped from 16 to fit the chainfist vwep

typedef struct
{
	char	name[MAX_QPATH];
	char	cinfo[MAX_QPATH];
	struct image_s	*skin;
	struct image_s	*icon;
	char	iconname[MAX_QPATH];
	struct model_s	*model;
	struct model_s	*weaponmodel[MAX_CLIENTWEAPONMODELS];
} clientinfo_t;

extern char cl_weaponmodels[MAX_CLIENTWEAPONMODELS][MAX_QPATH];
extern int num_cl_weaponmodels;

#define	CMD_BACKUP		64	// allow a lot of command backups for very fast systems

typedef enum
{
	// generic types
	DL_OTHER,
	DL_MAP,
	DL_MODEL,
	DL_LIST,
	DL_PAK
} dltype_t;

// download queue state
typedef enum
{
	DL_PENDING,
	DL_RUNNING,
	DL_DONE
} dlstate_t;

// download queue
typedef struct dlqueue_s
{
	struct dlqueue_s	*next;
	dltype_t			type;
	dlstate_t			state;
	char				path[MAX_QPATH];
} dlqueue_t;

// cinematics
typedef struct
{
	char		name[MAX_QPATH];

	roq_chunk_t chunk;
	roq_cell_t	cells[256];
	roq_qcell_t qcells[256];

	byte		*y[2], *u[2], *v[2];

	qboolean	restart_sound;

	int			s_rate;
	int			s_width;
	int			s_channels;

	int			width;
	int			width_2;			// width / 2
	int			height;

	fileHandle_t file;
	int			remaining;

	unsigned int time;				// Sys_Milliseconds for first cinematic frame
	unsigned int frame;

	byte		*buf;
	byte		*pic;
	byte		*pic_pending;
} cinematics_t;

//
// the client_state_t structure is wiped completely at every
// server map change
//
typedef struct
{
	int			timeoutcount;

	int			timedemo_frames;
	int			timedemo_start;

	qboolean	refresh_prepped;	// false if on new level or new ref dll
	qboolean	sound_prepped;		// ambient sounds can start
	qboolean	force_refdef;		// vid has changed, so we can't use a paused refdef

	int			parse_entities;		// index (not anded off) into cl_parse_entities[]

	usercmd_t	cmd;
	usercmd_t	cmds[CMD_BACKUP];	// each mesage will send several old cmds
	int			cmd_time[CMD_BACKUP];	// time sent, for calculating pings
	short		predicted_origins[CMD_BACKUP][3];	// for debug comparing against server

	float		predicted_step;				// for stair up smoothing
	unsigned	predicted_step_time;

	vec3_t		predicted_origin;	// generated by CL_PredictMovement
	vec3_t		predicted_angles;
	vec3_t		prediction_error;

	frame_t		frame;				// received from server
	int			surpressCount;		// number of messages rate supressed
	frame_t		frames[UPDATE_BACKUP];

	// the client maintains its own idea of view angles, which are
	// sent to the server each frame. It is cleared to 0 upon entering each level.
	// the server sends a delta each frame which is added to the locally
	// tracked view angles to account for standing on rotating objects,
	// and teleport direction changes
	vec3_t		viewangles;

	int			time;			// this is the time value that the client
	// is rendering at. always <= cls.realtime
	float		lerpfrac;		// between oldframe and frame

	refdef_t	refdef;

	vec3_t		v_forward, v_right, v_up;	// set when refdef.angles is set

	//
	// transient data from server
	//
	char		layout[1024];		// general 2D overlay
	int			inventory[MAX_ITEMS];

	// non-gameserver infornamtion
	cinematics_t cin;

	//
	// server state information
	//
	qboolean	attractloop;		// running the attract loop, any key will menu
	int			servercount;	// server identification for prespawns
	char		gamedir[MAX_QPATH];
	int			playernum;

	char		configstrings[MAX_CONFIGSTRINGS][MAX_QPATH];

	//
	// locally derived information from server state
	//
	struct model_s	*model_draw[MAX_MODELS];
	struct cmodel_s	*model_clip[MAX_MODELS];

	struct sfx_s	*sound_precache[MAX_SOUNDS];
	struct image_s	*image_precache[MAX_IMAGES];

	clientinfo_t	clientinfo[MAX_CLIENTS];
	clientinfo_t	baseclientinfo;
} client_state_t;

extern	client_state_t	cl;

/*
==================================================================

the client_static_t structure is persistant through an arbitrary number
of server connections

==================================================================
*/

typedef enum
{
	ca_uninitialized,
	ca_disconnected, 	// not talking to a server
	ca_connecting,		// sending request packets to the server
	ca_connected,		// netchan_t established, waiting for svc_serverdata
	ca_active			// game views should be displayed
} connstate_t;

typedef enum {key_game, key_console, key_message, key_menu} keydest_t;

typedef struct
{
	connstate_t	state;
	keydest_t	key_dest;

	int			framecount;
	int			realtime;			// always increasing, no clamping, etc
	float		rframetime;			// seconds since last render frame
	float		nframetime;			// network frame time

	// screen rendering information
	float		disable_screen;		// showing loading plaque between levels
	// or changing rendering dlls
	// if time gets > 30 seconds ahead, break it
	int			disable_servercount;	// when we receive a frame and cl.servercount
	// > cls.disable_servercount, clear disable_screen

	// connection information
	char		servername[MAX_OSPATH];	// name of server from original connect
	float		connect_time;		// for connection retransmits

	int			quakePort;			// a 16 bit value that allows quake servers to work around address translating routers
	netchan_t	netchan;
	int			serverProtocol;		// in case we are doing some kind of version hack

	int			challenge;			// from the server to use for connecting

	qboolean	forcePacket;		// forces a packet to be send at the next frame
	netadr_t	last_rcon_to;		// last destination client sent an rcon to

	// file transfer from server
	struct {
		dlqueue_t   *current; // current path being downloaded
		dlqueue_t	queue; // path being downloaded
		int         pending; // number of non-finished entries in queue
		char		tempname[MAX_OSPATH + 4]; // account 4 bytes for .tmp suffix
		char		name[MAX_OSPATH];
		FILE		*file; // UDP file transfer from server
		int			percent; // how much downloaded
		size_t		position; // how much downloaded (in bytes)
	} download;

	// for gamespy
	int			gamespypercent;
	int			gamespyupdate;
	int			gamespytotalservers;
	int			gamespystarttime;

	// demo recording info must be here, so it isn't cleared on level change
	qboolean	demorecording;
	qboolean	demowaiting;	// don't record until a non-delta message is received
	FILE		*demofile;

	// true type fonts
	fontInfo_t	consoleFont;
	fontInfo_t	consoleBoldFont;
} client_static_t;

extern client_static_t	cls;

//=============================================================================

//
// cvars
//
extern	cvar_t	*cl_stereo_separation;
extern	cvar_t	*cl_stereo;

extern	cvar_t	*cl_drawParticles;
extern	cvar_t	*cl_particleCollision;

extern	cvar_t	*cl_gun;
extern	cvar_t	*cl_gunAlpha;
extern	cvar_t	*cl_predict;
extern	cvar_t	*cl_footsteps;
extern	cvar_t	*cl_noskins;
extern	cvar_t	*cl_autoskins;

extern	cvar_t	*cl_upspeed;
extern	cvar_t	*cl_forwardspeed;
extern	cvar_t	*cl_sidespeed;

extern	cvar_t	*cl_yawspeed;
extern	cvar_t	*cl_pitchspeed;

extern	cvar_t	*cl_run;

extern	cvar_t	*cl_anglespeedkey;

extern	cvar_t	*cl_shownet;
extern	cvar_t	*cl_showmiss;
extern	cvar_t	*cl_showclamp;
extern	cvar_t	*cl_showfps;

extern	cvar_t	*lookstrafe;
extern	cvar_t	*sensitivity;

extern	cvar_t	*m_pitch;
extern	cvar_t	*m_yaw;
extern	cvar_t	*m_forward;
extern	cvar_t	*m_side;

extern	cvar_t	*freelook;

extern	cvar_t	*cl_lightlevel;	// FIXME HACK

extern	cvar_t	*cl_paused;
extern	cvar_t	*cl_timedemo;

extern	cvar_t	*cl_aviFrameRate;

extern	cvar_t	*cl_vwep;

extern	cvar_t	*cl_http_downloads;
extern	cvar_t	*cl_http_filelists;
extern	cvar_t	*cl_http_proxy;
extern	cvar_t	*cl_http_max_connections;
extern	cvar_t	*cl_http_default_url;

typedef struct
{
	int		key;				// so entities can reuse same entry
	vec3_t	color;
	vec3_t	origin;
	float	radius;
	float	die;				// stop lighting after this time
	float	decay;				// drop this each second
	float	minlight;			// don't add when contributing less
} cdlight_t;

extern	centity_t	cl_entities[MAX_EDICTS];
extern	cdlight_t	cl_dlights[MAX_LIGHTS];

// the cl_parse_entities must be large enough to hold UPDATE_BACKUP frames of
// entities, so that when a delta compressed message arives from the server
// it can be un-deltad from the original
#define	MAX_PARSE_ENTITIES	1024
extern	entity_state_t	cl_parse_entities[MAX_PARSE_ENTITIES];

//=============================================================================

extern	netadr_t	net_from;
extern	sizebuf_t	net_message;

void CL_AddNetgraph (void);

//=============================================================================

typedef struct particle_s
{
	struct particle_s	*next;

	float		time;

	vec3_t		org;
	vec3_t		oldOrg;
	vec3_t		vel;
	vec3_t		accel;
	float		color;
	float		colorvel;
	float		alpha;
	float		alphavel;
	float		bounceFactor;
	qboolean	ignoreGrav;
} cparticle_t;

#define	PARTICLE_GRAVITY	40
#define BLASTER_PARTICLE_COLOR 0xe0
#define INSTANT_PARTICLE	-10000.0

void CL_ClearEffects (void);
void CL_ClearTEnts (void);
void CL_BlasterTrail (vec3_t start, vec3_t end, float color);
void CL_QuadTrail (vec3_t start, vec3_t end);
void CL_RailTrail (vec3_t start, vec3_t end);
void CL_BubbleTrail (vec3_t start, vec3_t end);
void CL_FlagTrail (vec3_t start, vec3_t end, float color);

void CL_TeleporterParticles (entity_state_t *ent);
void CL_ParticleEffect (vec3_t org, vec3_t dir, int color, int count);
void CL_ParticleEffect2 (vec3_t org, vec3_t dir, int color, int count);

int CL_ParseEntityBits (unsigned *bits);
void CL_ParseDelta (entity_state_t *from, entity_state_t *to, int number, int bits);
void CL_ParseFrame (void);

void CL_ParseTEnt (void);
void CL_ParseConfigString (void);
void CL_ParseMuzzleFlash (void);
void CL_ParseMuzzleFlash2 (void);
void CL_SmokeAndFlash (vec3_t origin);

void CL_SetLightstyle (int i);

void CL_RunDLights (void);
void CL_RunLightStyles (void);

void CL_AddEntities (void);
void CL_AddDLights (void);
void CL_AddTEnts (void);
void CL_AddLightStyles (void);

//=================================================

void CL_PrepRefresh (void);
void CL_RegisterSounds (void);

void CL_Quit_f (void);

//
// cl_main
//
void CL_Init (void);

void CL_FixUpGender (void);
void CL_Disconnect (void);
void CL_Disconnect_f (void);
void CL_PingServers_f (void);
void CL_Snd_Restart_f (void);
void CL_WriteConfiguration (void);
void CL_Begin (void);

//
// cl_input
//
typedef struct
{
	int			down[2];		// key nums holding it down
	unsigned	downtime;		// msec timestamp
	unsigned	msec;			// msec down this frame
	int			state;
} kbutton_t;

extern	kbutton_t	in_mlook, in_klook;
extern 	kbutton_t 	in_strafe;
extern 	kbutton_t 	in_speed;

void CL_InitInput (void);
void CL_RefreshCmd (void);
void CL_SendCmd (void);

void CL_ClearState (void);

void CL_ReadPackets (void);

void CL_RefreshMove (void);

void CL_BaseMove (usercmd_t *cmd);

void IN_CenterView (void);

float CL_KeyState (kbutton_t *key);
char *Key_KeynumToString (int keynum);

//
// cl_console.c
//
void Con_CheckResize (void);
void Con_Init (void);
void Con_RunConsole (void);
void Con_DrawConsole (float frac);
void Con_Print (char *txt);
void Con_Clear_f (void);
void Con_DrawNotify (void);
void Con_ClearNotify (void);
void Con_ToggleConsole_f (void);
void Con_PageUp (void);
void Con_PageDown (void);
void Con_Top (void);
void Con_Bottom (void);

//
// cl_demo.c
//
void CL_WriteDemoMessage (void);
void CL_Stop_f (void);
void CL_Record_f (void);

//
// cl_parse.c
//
extern	char *svc_strings[256];

void CL_ParseServerMessage (void);
void CL_ParsePlayerSkin (char *name, char *model, char *skin, char *s);
void CL_LoadClientinfo (clientinfo_t *ci, char *s);
void SHOWNET (char *s);
void CL_ParseClientinfo (int player);

//
// cl_view.c
//
extern	int			gun_frame;
extern	struct model_s	*gun_model;

void V_Init (void);
void V_RenderView (float stereo_separation);
void V_AddEntity (entity_t *ent);
void V_AddParticle (vec3_t org, int color, float alpha);
void V_AddLight (vec3_t org, float intensity, float r, float g, float b);
void V_AddLightStyle (int style, float r, float g, float b);

//
// cl_tent.c
//
void CL_RegisterTEntSounds (void);
void CL_RegisterTEntModels (void);

//
// cl_pred.c
//
void CL_PredictMovement(void);
void CL_CheckPredictionError (void);

//
// cl_fx.c
//
cdlight_t *CL_AllocDlight (int key);
void CL_BigTeleportParticles (vec3_t org);
void CL_RocketTrail (vec3_t start, vec3_t end, centity_t *old);
void CL_DiminishingTrail (vec3_t start, vec3_t end, centity_t *old, int flags);
void CL_FlyEffect (centity_t *ent, vec3_t origin);
void CL_BfgParticles (entity_t *ent);
void CL_AddParticles (void);
void CL_EntityEvent (entity_state_t *ent);

//
// cl_gamespy.c
//
#define MAX_SERVERS 512 // FS: There's barely 200 active servers existing, but OK.
#define SHOW_POPULATED_SERVERS 1
#define SHOW_ALL_SERVERS 2
typedef struct
{
	char ip[16];
	int port;
	int ping;
	char hostname[32];
	int curPlayers;
	int maxPlayers;
	char mapname[32];
	int menuNumber;
} gamespyBrowser_t;

extern gamespyBrowser_t browserList[MAX_SERVERS];
extern gamespyBrowser_t browserListAll[MAX_SERVERS];
void CL_GameSpy_Async_Think (void);
void CL_GameSpy_PingServers_f (void);
void CL_GameSpy_Init (void);

//
// menus
//
extern char *menu_in_sound;
extern char *menu_move_sound;
extern char *menu_out_sound;

extern char *m_popup_string;
extern int m_popup_endtime;

#define NUM_ADDRESSBOOK_ENTRIES 9

void M_Init (void);
void M_Keydown (int key, qboolean down);
void M_MouseMove (int mx, int my);
void M_Draw (void);

char *Default_MenuKey (struct _tag_menuframework *m, int key);

void M_Print (int x, int y, char *str);
void M_DrawTextBox (int x, int y, int width, int lines);
void M_Banner (char *name);
void M_Popup (void);

void M_Menu_Main_f (void);

void M_ForceMenuOff (void);
void M_PopMenu (void);
void M_PushMenu (struct _tag_menuframework *menu);

void M_AddToServerList (netadr_t adr, char *info);

void M_Menu_Main_f(void);
	void M_Menu_Game_f(void);
		void M_Menu_LoadGame_f(void);
		void M_Menu_SaveGame_f(void);
		void M_Menu_Credits_f(void);
	void M_Menu_Multiplayer_f(void);
		void M_Menu_JoinGamespyServer_f(void);
		void M_Menu_JoinServer_f(void);
			void M_Menu_AddressBook_f(void);
		void M_Menu_StartServer_f(void);
			void M_Menu_DMOptions_f(void);
		void M_Menu_PlayerConfig_f(void);
		void M_Menu_DownloadOptions_f(void);
	void M_Menu_Options_f(void);
		void M_Menu_Options_Sound_f(void);
		void M_Menu_Options_Controls_f(void);
			void M_Menu_Keys_f(void);
		void M_Menu_Options_Screen_f(void);
		void M_Menu_Options_Effects_f(void);
	void M_Menu_Video_f(void);
	void M_Menu_Quit_f(void);

//
// cl_inv.c
//
void CL_ParseInventory (void);
void CL_DrawInventory (void);

//
// cl_download.c
//
qboolean CL_QueueDownload (char *quakePath, dltype_t type);
void CL_FinishDownload (dlqueue_t *q);
void CL_CleanupDownloads (void);
void CL_HandleDownload (byte *data, int size, int percent);
qboolean CL_CheckDownloadExtension (char *ext);
void CL_StartNextDownload (void);
void CL_RequestNextDownload (void);
void CL_ResetPrecacheCheck (void);
void CL_Download_f (void);

//
// cl_http.c
//
void CL_CleanupHTTPDownloads (void);
void CL_InitHTTPDownloads (void);
void CL_ShutdownHTTPDownloads (void);
qboolean CL_QueueHTTPDownload (char *quakePath, dltype_t type);
void CL_RunHTTPDownloads (void);
void CL_SetHTTPServer (const char *URL);

//
// cl_avi.c
//
qboolean CL_OpenAVIForWriting (const char *filename);
void CL_TakeVideoFrame (void);
void CL_WriteAVIVideoFrame (const byte *imageBuffer, int size);
void CL_WriteAVIAudioFrame (const byte *pcmBuffer, int size);
qboolean CL_CloseAVI (void);
qboolean CL_VideoRecording (void);
